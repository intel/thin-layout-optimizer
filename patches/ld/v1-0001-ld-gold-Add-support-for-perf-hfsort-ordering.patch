From 42e3ccbfb339334c136f0e0854ae51ef8375c144 Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Tue, 2 Apr 2024 11:09:44 -0500
Subject: ld/gold: Add support for perf-hfsort ordering

1) Make gold/ld read ordering files from env variables. This includes
   map files that will find the ordering script for a given target.

2) Support alignment in the ordering files.

3) Add text-ordering support in ld.
---
 gold/gold.cc                             |   2 +-
 gold/layout.cc                           |  56 +++-
 gold/layout.h                            |   2 +-
 gold/main.cc                             |  12 +-
 gold/options.h                           |   4 +-
 gold/output.cc                           |  14 +-
 gold/parameters.cc                       |  55 ++++
 gold/parameters.h                        |  39 ++-
 gold/target.h                            |  12 +
 include/ld-and-gold-env-scripts.h        | 386 +++++++++++++++++++++++
 include/ld-and-gold-sect-alignment-tab.h | 143 +++++++++
 ld/ld.h                                  |   3 +
 ld/ldemul.c                              |   6 +
 ld/ldemul.h                              |   2 +
 ld/ldfile.c                              |  25 +-
 ld/ldlang.c                              |  25 +-
 ld/ldlex.h                               |   1 +
 ld/ldmain.c                              |   8 +-
 ld/lexsup.c                              |  38 ++-
 ld/scripttempl/arclinux.sc               |   5 +-
 ld/scripttempl/avr.sc                    |   1 +
 ld/scripttempl/dlx.sc                    |   1 +
 ld/scripttempl/elf.sc                    |   1 +
 ld/scripttempl/elf32cr16.sc              |   1 +
 ld/scripttempl/elf32crx.sc               |   1 +
 ld/scripttempl/elf32msp430.sc            |   1 +
 ld/scripttempl/elf64bpf.sc               |   5 +-
 ld/scripttempl/elf64hppa.sc              |   1 +
 ld/scripttempl/elfarc.sc                 |   1 +
 ld/scripttempl/elfarcv2.sc               |   1 +
 ld/scripttempl/elfd10v.sc                |   1 +
 ld/scripttempl/elfd30v.sc                |   1 +
 ld/scripttempl/elfm68hc11.sc             |   1 +
 ld/scripttempl/elfm68hc12.sc             |   1 +
 ld/scripttempl/elfm9s12z.sc              |   1 +
 ld/scripttempl/elfmicroblaze.sc          |   1 +
 ld/scripttempl/elfxgate.sc               |   1 +
 ld/scripttempl/elfxtensa.sc              |   1 +
 ld/scripttempl/ft32.sc                   |   1 +
 ld/scripttempl/i386beos.sc               |   1 +
 ld/scripttempl/i386go32.sc               |   1 +
 ld/scripttempl/iq2000.sc                 |   1 +
 ld/scripttempl/mcorepe.sc                |   1 +
 ld/scripttempl/mep.sc                    |   1 +
 ld/scripttempl/mmo.sc                    |   1 +
 ld/scripttempl/nds32elf.sc               |   5 +-
 ld/scripttempl/pe.sc                     |   1 +
 ld/scripttempl/pep.sc                    |   1 +
 ld/scripttempl/pru.sc                    |   1 +
 ld/scripttempl/v850.sc                   |   1 +
 ld/scripttempl/v850_rh850.sc             |   1 +
 ld/scripttempl/visium.sc                 |   1 +
 ld/scripttempl/xstormy16.sc              |   1 +
 ld/testsuite/ld-elf/text-order-1.d       |  13 +
 ld/testsuite/ld-elf/text-order-1.t       |   4 +
 ld/testsuite/ld-elf/text-order-1a.s      |  10 +
 ld/testsuite/ld-elf/text-order-1b.s      |  10 +
 57 files changed, 882 insertions(+), 34 deletions(-)
 create mode 100644 include/ld-and-gold-env-scripts.h
 create mode 100644 include/ld-and-gold-sect-alignment-tab.h
 create mode 100644 ld/testsuite/ld-elf/text-order-1.d
 create mode 100644 ld/testsuite/ld-elf/text-order-1.t
 create mode 100644 ld/testsuite/ld-elf/text-order-1a.s
 create mode 100644 ld/testsuite/ld-elf/text-order-1b.s

diff --git a/gold/gold.cc b/gold/gold.cc
index 9fcb1f272d6..c1a6f448d28 100644
--- a/gold/gold.cc
+++ b/gold/gold.cc
@@ -568,7 +568,7 @@ queue_middle_tasks(const General_options& options,
      also specified, do not do anything here.  */
   if (parameters->options().has_plugins()
       && layout->is_section_ordering_specified()
-      && !parameters->options().section_ordering_file ())
+      && !parameters->get_section_ordering_file ())
     {
       for (Layout::Section_list::const_iterator p
 	     = layout->section_list().begin();
diff --git a/gold/layout.cc b/gold/layout.cc
index b94855f8662..8e57776e657 100644
--- a/gold/layout.cc
+++ b/gold/layout.cc
@@ -2086,6 +2086,7 @@ Layout::attach_allocated_section_to_segment(const Target* target,
 	{
 	  Output_segment* oseg = this->make_output_segment(elfcpp::PT_NOTE,
 							   seg_flags);
+
 	  oseg->add_output_section_to_nonload(os, seg_flags);
 	  oseg->set_align(os_align);
 	}
@@ -2918,17 +2919,32 @@ Layout::find_section_order_index(const std::string& section_name)
 // Read the sequence of input sections from the file specified with
 // option --section-ordering-file.

-void
+Exit_status
 Layout::read_layout_from_file()
 {
-  const char* filename = parameters->options().section_ordering_file();
+  const char* filename = parameters->get_section_ordering_file();
+  bool mayfail = parameters->section_ordering_file_mayfail();
   std::ifstream in;
   std::string line;

   in.open(filename);
-  if (!in)
-    gold_fatal(_("unable to open --section-ordering-file file %s: %s"),
-	       filename, strerror(errno));
+  if (!in) {
+       if (mayfail)
+	 {
+	   gold_fatal (
+	       _ ("unable to open --section-ordering-file file %s: %s"),
+	       filename, strerror (errno));
+	 }
+       else
+	 {
+	   gold_debug (DEBUG_FILES,
+		       "Unable to open LD_ORDERING_FILE file %s: %s", filename,
+		       strerror (errno));
+	   return GOLD_ERR;
+	 }
+  }
+
+  gold_debug (DEBUG_FILES, "Using section ordering file %s", filename);

   File_read::record_file_read(filename);

@@ -2940,12 +2956,32 @@ Layout::read_layout_from_file()
     {
       if (!line.empty() && line[line.length() - 1] == '\r')   // Windows
 	line.resize(line.length() - 1);
-      // Ignore comments, beginning with '#'
-      if (line[0] == '#')
+      // Ignore comments
+      size_t comment_pos = line.find('#');
+      if (comment_pos != std::string::npos)
 	{
-	  std::getline(in, line);
-	  continue;
+	   line = line.substr (0, comment_pos);
+	}
+      // Trim whitespace
+      size_t leading_ws = line.find_first_not_of (" \t");
+      if (leading_ws == std::string::npos)
+	{
+	   line.clear ();
+	}
+      else
+	{
+	   size_t trailing_ws = line.find_last_not_of (" \t");
+	   size_t trimmed_size = trailing_ws - leading_ws + 1;
+	   line = line.substr (leading_ws, trimmed_size);
+	}
+
+      if (line.empty())
+	{
+	   std::getline (in, line);
+	   continue;
 	}
+
+
       this->input_section_position_[line] = position;
       // Store all glob patterns in a vector.
       if (is_wildcard_string(line.c_str()))
@@ -2953,6 +2989,8 @@ Layout::read_layout_from_file()
       position++;
       std::getline(in, line);
     }
+
+  return GOLD_OK;
 }

 // Finalize the layout.  When this is called, we have created all the
diff --git a/gold/layout.h b/gold/layout.h
index 040c98cd9aa..e7a05f564ed 100644
--- a/gold/layout.h
+++ b/gold/layout.h
@@ -617,7 +617,7 @@ class Layout

   // Read the sequence of input sections from the file specified with
   // linker option --section-ordering-file.
-  void
+  Exit_status
   read_layout_from_file();

   // Layout an input reloc section when doing a relocatable link.  The
diff --git a/gold/main.cc b/gold/main.cc
index c6aa1901a95..5e3cd6a0d60 100644
--- a/gold/main.cc
+++ b/gold/main.cc
@@ -50,6 +50,8 @@
 #include "gdb-index.h"
 #include "timer.h"

+#include "ld-and-gold-sect-alignment-tab.h"
+
 using namespace gold;

 // This function emits the commandline to a hard-coded file in temp.
@@ -174,6 +176,8 @@ main(int argc, char** argv)
   // Store some options in the globally accessible parameters.
   set_parameters_options(&command_line.options());

+  set_parameters_section_ordering_file_from_env();
+
   // Do this as early as possible (since it prints a welcome message).
   write_debug_script(command_line.options().output_file_name(),
                      program_name, args.c_str());
@@ -232,8 +236,9 @@ main(int argc, char** argv)
   if (layout.incremental_inputs() != NULL)
     layout.incremental_inputs()->report_command_line(argc, argv);

-  if (parameters->options().section_ordering_file())
-    layout.read_layout_from_file();
+  if (parameters->get_section_ordering_file())
+    if (layout.read_layout_from_file() == GOLD_ERR)
+      set_parameters_section_ordering_file_failure();

   // Load plugin libraries.
   if (command_line.options().has_plugins())
@@ -323,6 +328,9 @@ main(int argc, char** argv)
   if (mapfile != NULL)
     mapfile->close();

+  ld_and_gold_tab_drop ();
+
+
   if (parameters->options().fatal_warnings()
       && errors.warning_count() > 0
       && errors.error_count() == 0)
diff --git a/gold/options.h b/gold/options.h
index 46f658f23ea..bb4dfa1e88b 100644
--- a/gold/options.h
+++ b/gold/options.h
@@ -1243,7 +1243,9 @@ class General_options
 	      N_("Strip LTO intermediate code sections"), NULL);

   DEFINE_string(section_ordering_file, options::TWO_DASHES, '\0', NULL,
-		N_("Layout sections in the order specified"),
+		N_("Layout sections in the order specified. May also be "
+		   "specified using the environment variable "
+		   "'GOLD_ORDERING_SCRIPT'"),
 		N_("FILENAME"));

   DEFINE_special(section_start, options::TWO_DASHES, '\0',
diff --git a/gold/output.cc b/gold/output.cc
index a1978eb5f32..0eb892a27df 100644
--- a/gold/output.cc
+++ b/gold/output.cc
@@ -46,6 +46,8 @@
 #include "layout.h"
 #include "output.h"

+#include "ld-and-gold-sect-alignment-tab.h"
+
 // For systems without mmap support.
 #ifndef HAVE_MMAP
 # define mmap gold_mmap
@@ -2409,6 +2411,16 @@ Output_section::add_input_section(Layout* layout,
 				    &addralign))
     input_section_size = uncompressed_size;

+  uint64_t alignment = ld_and_gold_tab_find (secname);
+  if (alignment != LD_AND_GOLD_BAD_ALIGN_POW && alignment < 32)
+    {
+      alignment = uint64_t (1) << alignment;
+      if (alignment > addralign)
+	{
+	  addralign = alignment;
+	}
+    }
+
   if ((addralign & (addralign - 1)) != 0)
     {
       object->error(_("invalid alignment %lu for section \"%s\""),
@@ -2532,7 +2544,7 @@ Output_section::add_input_section(Layout* layout,
       /* If section ordering is requested by specifying a ordering file,
 	 using --section-ordering-file, match the section name with
 	 a pattern.  */
-      if (parameters->options().section_ordering_file())
+      if (parameters->get_section_ordering_file())
 	{
 	  unsigned int section_order_index =
 	    layout->find_section_order_index(std::string(secname));
diff --git a/gold/parameters.cc b/gold/parameters.cc
index 90bc4db8d46..c6b4364310c 100644
--- a/gold/parameters.cc
+++ b/gold/parameters.cc
@@ -26,6 +26,7 @@
 #include "options.h"
 #include "target.h"
 #include "target-select.h"
+#include "ld-and-gold-env-scripts.h"

 namespace gold
 {
@@ -231,6 +232,52 @@ Parameters::check_rodata_segment()
     gold_error(_("-Trodata-segment is meaningless without --rosegment"));
 }

+// Set the section_ordering_file using 'GOLD_ORDERING_SCRIPT' if the
+// user-option '--section-ordering-file' wasn't specified.
+void
+Parameters::set_section_ordering_file_from_env()
+{
+  const char *ret;
+  // If we have user-option or already had a failure, nothing to do.
+  if (this->options().section_ordering_file()
+  || this->section_ordering_file_has_failed_)
+    return;
+
+  // Read filepath from environment.
+  ret = ld_and_gold_get_ordering_script (
+      0, "GOLD_ORDERING_SCRIPT", "GOLD_ORDERING_SCRIPT_MAP",
+      this->options ().output_file_name (),
+      parameters->target_valid () ? parameters->target ().machine_code_name ()
+				  : NULL);
+
+  // If not set (or error), indicate we should stop trying to return.
+  if (ret == NULL)
+    {
+      this->section_ordering_file_has_failed_ = true;
+      return;
+    }
+  // Set env file.
+  section_ordering_file_from_env_ = ret;
+}
+
+// Return section_ordering_file, first checking user-option then checking env
+// variable input.
+const char *
+Parameters::get_section_ordering_file() const
+{
+  // If we have user-option return it.
+  const char *ret = this->options().section_ordering_file();
+  if (ret)
+    return ret;
+
+  // If we had any error using the env file then pretend it never existed.
+  if (this->section_ordering_file_has_failed_)
+    return NULL;
+
+  // Finally return env file. This may be NULL if it was never specified.
+  return this->section_ordering_file_from_env_;
+}
+
 // Return the name of the entry symbol.

 const char*
@@ -282,6 +329,14 @@ Parameters::incremental_update() const
 	  || this->incremental_mode_ == General_options::INCREMENTAL_AUTO);
 }

+void
+set_parameters_section_ordering_file_failure()
+{ static_parameters.set_section_ordering_file_failure(); }
+
+void
+set_parameters_section_ordering_file_from_env()
+{ static_parameters.set_section_ordering_file_from_env(); }
+
 void
 set_parameters_errors(Errors* errors)
 { static_parameters.set_errors(errors); }
diff --git a/gold/parameters.h b/gold/parameters.h
index 76202b186e4..ae389132c0a 100644
--- a/gold/parameters.h
+++ b/gold/parameters.h
@@ -176,7 +176,36 @@ class Parameters
   bool
   incremental_update() const;

- private:
+  // Get section_ordering_file. This first tries the user-option from
+  // '--section-ordering-file'. It ifs not present, it tries the file from the
+  // env variable 'GOLD_ORDERING_SCRIPT'.
+  const char *get_section_ordering_file() const;
+
+  // Set that we should throw error if we have IO issues with the
+  // section_order_file. It we are using the user-provided argument we throw
+  // error in the event of IO issue. If we are using the env version we ignore
+  // IO errors and stop using the section_ordering_file.
+  bool
+  section_ordering_file_mayfail() const
+  {
+    return this->section_ordering_file_from_env_ == NULL;
+  }
+
+  // Only relevent if we are using the env variable section_ordering_file. It
+  // indicates we failed doing IO on the file, so we want to pretend it never
+  // existed.
+  void
+  set_section_ordering_file_failure()
+  {
+    this->section_ordering_file_has_failed_ = true;
+  }
+
+  // Read environment variable 'GOLD_ORDERING_SCRIPT' and, if present,
+  // use its value for the section_ordering_file. Only relevent of user-option
+  // '--section-ordering-file' is not present.
+  void set_section_ordering_file_from_env();
+
+private:
   void
   set_target_once(Target*);

@@ -197,6 +226,8 @@ class Parameters
   int debug_;
   int incremental_mode_;
   Set_parameters_target_once* set_parameters_target_once_;
+  const char *section_ordering_file_from_env_ = NULL;
+  bool section_ordering_file_has_failed_ = false;
 };

 // This is a global variable.
@@ -205,6 +236,12 @@ extern const Parameters* parameters;
 // We use free functions for these since they affect a global variable
 // that is internal to parameters.cc.

+extern void
+set_parameters_section_ordering_file_failure();
+
+extern void
+set_parameters_section_ordering_file_from_env();
+
 extern void
 set_parameters_errors(Errors* errors);

diff --git a/gold/target.h b/gold/target.h
index 307c98f4a10..cf5a565a83c 100644
--- a/gold/target.h
+++ b/gold/target.h
@@ -88,6 +88,18 @@ class Target
   machine_code() const
   { return this->pti_->machine_code; }

+  const char *
+  machine_code_name () const
+  {
+    switch (machine_code ())
+      {
+      case elfcpp::EM::EM_X86_64:
+	return "elf_x86_64";
+      default:
+	return NULL;
+      }
+  }
+
   // Processor specific flags to store in e_flags field of ELF header.
   elfcpp::Elf_Word
   processor_specific_flags() const
diff --git a/include/ld-and-gold-env-scripts.h b/include/ld-and-gold-env-scripts.h
new file mode 100644
index 00000000000..10fc9192b0a
--- /dev/null
+++ b/include/ld-and-gold-env-scripts.h
@@ -0,0 +1,386 @@
+#ifndef BINUTILS_D_INCLUDE_D_LD_AND_GOLD_ENV_SCRIPTS_H_
+#define BINUTILS_D_INCLUDE_D_LD_AND_GOLD_ENV_SCRIPTS_H_
+
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <ctype.h>
+
+#include "ld-and-gold-sect-alignment-tab.h"
+
+htab_t G_ld_and_gold_alignment_tab = NULL;
+
+static int
+ld_and_gold_is_whitespace (char c)
+{
+  return c == ' ' || c == '\t';
+}
+
+static int
+ld_and_gold_is_digit (char c)
+{
+  return c >= '0' && c <= '9';
+}
+
+static struct ldg_func_sect_alignment_t *
+ld_and_gold_find_alignment (const char *line, size_t line_sz, int is_ld)
+{
+  const char *sect_begin;
+  const char *sect_end;
+  const char *begin_align_info;
+  char *sect_name_dup;
+  size_t sect_name_len, alloc_size;
+  void *mem;
+  const char to_match[] = { 'a', '=' };
+  unsigned to_match_idx = 0;
+  const char *line_end = line + line_sz;
+  if (line_sz == 0)
+    {
+      return NULL;
+    }
+
+  sect_begin = (const char *) memchr (line, '.', line_sz);
+  if (sect_begin == NULL)
+    {
+      return NULL;
+    }
+  line_sz = line_end - sect_begin;
+
+  sect_end = (const char *) memchr (sect_begin, is_ld ? ')' : ' ', line_sz);
+  if (sect_end == NULL)
+    {
+      return NULL;
+    }
+  line_sz = line_end - sect_end;
+  begin_align_info = (const char *) memchr (sect_end, '#', line_sz);
+  if (begin_align_info == NULL)
+    {
+      return NULL;
+    }
+  ++begin_align_info;
+
+  for (;;)
+    {
+      if (begin_align_info >= line_end)
+	{
+	  return NULL;
+	}
+      if (to_match_idx < sizeof (to_match)
+	  && begin_align_info[0] == to_match[to_match_idx])
+	{
+	  ++to_match_idx;
+	}
+      else if (!ld_and_gold_is_whitespace (begin_align_info[0]))
+	{
+	  break;
+	}
+      ++begin_align_info;
+    }
+
+  if (!ld_and_gold_is_digit (begin_align_info[0]))
+    {
+      return NULL;
+    }
+
+  unsigned alignment_power = begin_align_info[0] - '0';
+  ++begin_align_info;
+  if (begin_align_info < line_end
+      && ld_and_gold_is_digit (begin_align_info[0]))
+    {
+      alignment_power = alignment_power * 10 + begin_align_info[0] - '0';
+      ++begin_align_info;
+    }
+  if (begin_align_info < line_end
+      && !(ld_and_gold_is_whitespace (begin_align_info[0])
+	   || begin_align_info[0] == '\n' || begin_align_info[0] == '\0'))
+    {
+      return NULL;
+    }
+  sect_name_len = sect_end - sect_begin;
+  alloc_size = sizeof (struct ldg_func_sect_alignment_t) + sect_name_len + 1;
+  mem = malloc (alloc_size);
+  if (mem == NULL)
+    {
+      return NULL;
+    }
+
+  sect_name_dup = ((char *) mem) + sizeof (struct ldg_func_sect_alignment_t);
+  struct ldg_func_sect_alignment_t *func_sect_alignment
+      = (struct ldg_func_sect_alignment_t *) mem;
+
+  memcpy (sect_name_dup, sect_begin, sect_name_len);
+  sect_name_dup[sect_name_len] = '\0';
+  func_sect_alignment->func_sect_name_ = sect_name_dup;
+  func_sect_alignment->alignment_power_ = alignment_power;
+  func_sect_alignment->found_ = 0;
+  return func_sect_alignment;
+}
+
+static void
+ld_and_gold_add_alignments (const char *path, int is_ld)
+{
+  FILE *fp = NULL;
+  char *line = NULL;
+  size_t line_sz = 0;
+
+  fp = fopen (path, "r");
+  if (fp == NULL)
+    {
+      return;
+    }
+  for (;;)
+    {
+      ssize_t nread_s = getline (&line, &line_sz, fp);
+      size_t nread;
+      struct ldg_func_sect_alignment_t *alignment_info;
+      if (nread_s < 0)
+	{
+	  if (line != NULL)
+	    {
+	      free (line);
+	    }
+	  break;
+	}
+
+      nread = nread_s;
+      alignment_info = ld_and_gold_find_alignment (line, nread, is_ld);
+      if (alignment_info != NULL)
+	{
+	  if (ld_and_gold_tab_insert (alignment_info))
+	    {
+	      free (alignment_info);
+	    }
+	}
+    }
+  fclose (fp);
+}
+
+/* Find where the ".so" starts in a dso. If ".so" exists return offset to the
+ * 'o'. Otherwise return 0.  */
+static size_t
+ld_and_gold_dso_find_so (const char *dso, size_t dso_len)
+{
+  for (; dso_len > 2U; --dso_len)
+    {
+      if (dso[dso_len] == 'o' && dso[dso_len - 1] == 's'
+	  && dso[dso_len - 2] == '.')
+	{
+	  return dso_len;
+	}
+    }
+  return 0;
+}
+
+/* Returns true if two dsos match. If both dsos are shared libraries it will
+ * only match up to the last ".so".  */
+static int
+ld_and_gold_dso_matches (const char *dso0, size_t dso_len0, const char *dso1,
+			 size_t dso_len1)
+{
+  size_t len0 = ld_and_gold_dso_find_so (dso0, dso_len0);
+  if (len0 != 0)
+    {
+      size_t len1 = ld_and_gold_dso_find_so (dso1, dso_len1);
+      if (len0 == len1)
+	{
+	  return memcmp (dso0, dso1, len0) == 0;
+	}
+    }
+  return dso_len0 == dso_len1 && memcmp (dso0, dso1, dso_len0) == 0;
+}
+
+/* Try to read input linker-script or gold section-ordering-file from env 1. an
+ * env variable and 2. a map of DSO -> scripts if env variable (1) doesn't
+ * exist. Only takes affect if normal commandline arguments not present. */
+static char *
+ld_and_gold_get_ordering_script (int is_ld, const char *env_linker_script_in,
+				 const char *env_linker_script_map_in,
+				 const char *output_dso,
+				 const char *target_name)
+{
+  char *env_linker_script = NULL;
+  char *env_linker_script_end = NULL;
+  char *env_linker_script_map = NULL;
+  if (env_linker_script_in != NULL)
+    {
+      env_linker_script = getenv (env_linker_script_in);
+    }
+
+  if (env_linker_script == NULL || access (env_linker_script, F_OK) != 0)
+    {
+
+      char *line = NULL;
+      size_t line_sz = 0;
+      FILE *fp = NULL;
+      const char *output_dso_basename = NULL;
+      const char *output_dso_end = NULL;
+      size_t output_dso_len = 0;
+      size_t target_len = 0;
+      int target_okay = 0;
+      if (env_linker_script_map_in == NULL)
+	{
+	  return NULL;
+	}
+
+      if (output_dso == NULL)
+	{
+	  return NULL;
+	}
+
+      env_linker_script_map = getenv (env_linker_script_map_in);
+      if (env_linker_script_map == NULL)
+	{
+	  return NULL;
+	}
+
+      fp = fopen (env_linker_script_map, "r");
+      if (fp == NULL)
+	{
+	  return NULL;
+	}
+
+      output_dso_len = strlen (output_dso);
+      output_dso_end = output_dso + output_dso_len;
+
+      output_dso_basename = output_dso_end;
+      while (output_dso_basename != output_dso
+	     && (*output_dso_basename) != '/')
+	{
+	  --output_dso_basename;
+	}
+      if ((*output_dso_basename) == '/')
+	{
+	  ++output_dso_basename;
+	}
+      output_dso_len = output_dso_end - output_dso_basename;
+
+      if (target_name != NULL)
+	{
+	  target_len = strlen (target_name);
+	}
+      /* Default to accepting. If we reach a 'target:*' line then we start
+       * filtering.  */
+      target_okay = 1;
+      for (;;)
+	{
+	  char *end_dso, *cur_line;
+	  ssize_t nread_s;
+	  size_t nread;
+	  nread_s = getline (&line, &line_sz, fp);
+	  if (nread_s < 0)
+	    {
+	      if (line != NULL)
+		{
+		  free (line);
+		}
+	      break;
+	    }
+
+	  nread = nread_s;
+	  cur_line = line;
+	  while (nread > 0 && (cur_line[0] == ' ' || cur_line[0] == '\t'))
+	    {
+	      --nread;
+	      ++cur_line;
+	    }
+
+	  if (target_len != 0 && nread > strlen ("target:")
+	      && memcmp (cur_line, "target:", strlen ("target:")) == 0)
+	    {
+	      target_okay = 0;
+	      nread -= strlen ("target:");
+	      cur_line += strlen ("target:");
+
+	      for (;;)
+		{
+		  char *next_target;
+		  while (nread > 0
+			 && (cur_line[0] == ' ' || cur_line[0] == '\t'))
+		    {
+		      --nread;
+		      ++cur_line;
+		    }
+		  next_target = (char *) memchr (cur_line, ',', nread);
+		  if (next_target == NULL)
+		    {
+		      next_target = (char *) memchr (cur_line, '\n', nread);
+		      if (next_target == NULL)
+			{
+			  break;
+			}
+		    }
+		  if ((size_t) (next_target - cur_line) == target_len
+		      && memcmp (cur_line, target_name, target_len) == 0)
+		    {
+		      target_okay = 1;
+		      break;
+		    }
+		  if (cur_line + nread <= (next_target + 1))
+		    {
+		      break;
+		    }
+		  nread -= (ssize_t) ((next_target + 1) - cur_line);
+		  cur_line = next_target + 1;
+		}
+	      continue;
+	    }
+
+	  if (!target_okay)
+	    {
+	      continue;
+	    }
+
+	  end_dso = (char *) memchr (cur_line, ' ', nread);
+	  if (end_dso == NULL)
+	    {
+	      continue;
+	    }
+
+	  *end_dso = '\0';
+	  if (ld_and_gold_dso_matches (cur_line, end_dso - cur_line,
+				       output_dso_basename, output_dso_len))
+	    {
+	      do
+		{
+		  ++end_dso;
+		}
+	      while ((*end_dso) == ' ');
+	      /* We end up leaking memory allocated for line. Its a very
+	       * bounded amount we make leak so probably okay.  */
+	      env_linker_script = end_dso;
+	      break;
+	    }
+	}
+
+      fclose (fp);
+    }
+
+  if (env_linker_script == NULL)
+    {
+      return NULL;
+    }
+
+  env_linker_script_end = env_linker_script + strlen (env_linker_script) - 1;
+  while (env_linker_script_end > env_linker_script
+	 && (*env_linker_script_end == '\n' || *env_linker_script_end == ' '
+	     || *env_linker_script_end == '\t'))
+    {
+      *env_linker_script_end = '\0';
+      --env_linker_script_end;
+    }
+  if (access (env_linker_script, F_OK) != 0)
+    {
+      return NULL;
+    }
+
+  if (env_linker_script != NULL)
+    {
+      ld_and_gold_add_alignments (env_linker_script, is_ld);
+    }
+
+  return env_linker_script;
+}
+
+#endif
diff --git a/include/ld-and-gold-sect-alignment-tab.h b/include/ld-and-gold-sect-alignment-tab.h
new file mode 100644
index 00000000000..b026777282f
--- /dev/null
+++ b/include/ld-and-gold-sect-alignment-tab.h
@@ -0,0 +1,143 @@
+#ifndef BINUTILS_D_INCLUDE_D_LD_AND_GOLD_SECT_ALIGNMENT_TAB_H_
+#define BINUTILS_D_INCLUDE_D_LD_AND_GOLD_SECT_ALIGNMENT_TAB_H_ 1
+
+#include "hashtab.h"
+
+#define LD_AND_GOLD_BAD_ALIGN_POW 0
+
+extern htab_t G_ld_and_gold_alignment_tab;
+struct ldg_func_sect_alignment_t
+{
+  const char *func_sect_name_;
+  unsigned alignment_power_;
+  int found_;
+};
+
+static int
+ld_and_gold_fsa_eq (const void *lhs, const void *rhs)
+{
+  const struct ldg_func_sect_alignment_t *lhs_fda
+      = (const struct ldg_func_sect_alignment_t *) lhs;
+  const struct ldg_func_sect_alignment_t *rhs_fda
+      = (const struct ldg_func_sect_alignment_t *) rhs;
+
+  return strcmp (lhs_fda->func_sect_name_, rhs_fda->func_sect_name_) == 0;
+}
+
+static hashval_t
+ld_and_gold_fsa_hash (const void *n)
+{
+  const struct ldg_func_sect_alignment_t *n_fda
+      = (const struct ldg_func_sect_alignment_t *) n;
+  const char *str = n_fda->func_sect_name_;
+  hashval_t hv = 0;
+  for (;;)
+    {
+      char c = str[0];
+      if (c == '\0')
+	{
+	  break;
+	}
+      hv += (hv * 65599) + c;
+      ++str;
+    }
+  return hv ^ (hv >> 16);
+}
+static int
+ld_and_gold_fda_startswith (const struct ldg_func_sect_alignment_t *fda,
+			    const char *prefix)
+{
+  return strncmp (fda->func_sect_name_, prefix, strlen (prefix)) == 0;
+}
+static void
+ld_and_gold_fsa_del (void *p)
+{
+  struct ldg_func_sect_alignment_t *fda
+      = (struct ldg_func_sect_alignment_t *) p;
+  if (!fda->found_)
+    {
+      /* If found in one of these sections its likely just due to duplicate. */
+      if (!ld_and_gold_fda_startswith (fda, ".text.cold.")
+	  && !ld_and_gold_fda_startswith (fda, ".text.hot.")
+	  && !ld_and_gold_fda_startswith (fda, ".text.unlikely.")
+	  && !ld_and_gold_fda_startswith (fda, ".text.likely."))
+	{
+	  printf ("Warning: %s was never aligned to %u\n",
+		  fda->func_sect_name_, fda->alignment_power_);
+	}
+    }
+  free (p);
+}
+
+static htab_t
+ld_and_gold_tab_get (void)
+{
+  if (G_ld_and_gold_alignment_tab == NULL)
+    {
+      G_ld_and_gold_alignment_tab = htab_create (
+	  32, ld_and_gold_fsa_hash, ld_and_gold_fsa_eq, ld_and_gold_fsa_del);
+    }
+  return G_ld_and_gold_alignment_tab;
+}
+static int
+ld_and_gold_tab_drop (void)
+{
+  int ret = 0;
+  if (G_ld_and_gold_alignment_tab == NULL)
+    {
+      return ret;
+    }
+  ret = htab_elements (G_ld_and_gold_alignment_tab) != 0;
+  htab_delete (G_ld_and_gold_alignment_tab);
+  return ret;
+}
+
+#if !(defined LD_AND_GOLD_NWG_TESTING)
+static int
+ld_and_gold_tab_insert (struct ldg_func_sect_alignment_t *fda)
+{
+  htab_t tab = ld_and_gold_tab_get ();
+  void **slot;
+  if (tab == NULL)
+    {
+      return 1;
+    }
+  slot = htab_find_slot (tab, (void *) fda, INSERT);
+  if (slot == NULL)
+    {
+      return 1;
+    }
+  *slot = (void *) fda;
+  return 0;
+}
+#endif
+
+static unsigned
+ld_and_gold_tab_find (const char *s)
+{
+  struct ldg_func_sect_alignment_t fda = { s, 0, 0 };
+  htab_t tab = ld_and_gold_tab_get ();
+  unsigned alignment_power = LD_AND_GOLD_BAD_ALIGN_POW;
+  struct ldg_func_sect_alignment_t *found_fda;
+  void **slot;
+  if (tab == NULL)
+    {
+      return alignment_power;
+    }
+  slot = htab_find_slot (tab, (void *) &fda, NO_INSERT);
+  if (slot == NULL)
+    {
+      return alignment_power;
+    }
+  found_fda = ((struct ldg_func_sect_alignment_t *) (*slot));
+  alignment_power = found_fda->alignment_power_;
+  found_fda->found_ = 1;
+  if (alignment_power == LD_AND_GOLD_BAD_ALIGN_POW)
+    {
+      printf ("Warning: %s has bad alignment power\n",
+	      found_fda->func_sect_name_);
+    }
+  return alignment_power;
+}
+
+#endif
diff --git a/ld/ld.h b/ld/ld.h
index a0f8a15c7a9..f590d7de95e 100644
--- a/ld/ld.h
+++ b/ld/ld.h
@@ -313,6 +313,9 @@ typedef struct

   /* Compress DWARF debug sections.  */
   enum compressed_debug_section_type compress_debug;
+
+  /* The optional text section ordering file.  */
+  const char *text_section_ordering_file;
 } ld_config_type;

 extern ld_config_type config;
diff --git a/ld/ldemul.c b/ld/ldemul.c
index d0943de1f2a..7e0693753f3 100644
--- a/ld/ldemul.c
+++ b/ld/ldemul.c
@@ -59,6 +59,12 @@ ldemul_before_parse (void)
   ld_emulation->before_parse ();
 }

+const char *
+ldemul_emulation_name (void)
+{
+  return ld_emulation == NULL ? NULL : ld_emulation->emulation_name;
+}
+
 void
 ldemul_before_plugin_all_symbols_read (void)
 {
diff --git a/ld/ldemul.h b/ld/ldemul.h
index f3e8bb697f4..ab30891bfbc 100644
--- a/ld/ldemul.h
+++ b/ld/ldemul.h
@@ -32,6 +32,8 @@ extern void ldemul_after_parse
   (void);
 extern void ldemul_before_parse
   (void);
+extern const char * ldemul_emulation_name
+  (void);
 extern void ldemul_before_plugin_all_symbols_read
   (void);
 extern void ldemul_after_open
diff --git a/ld/ldfile.c b/ld/ldfile.c
index df7c9cbd65e..30c46b61587 100644
--- a/ld/ldfile.c
+++ b/ld/ldfile.c
@@ -255,7 +255,7 @@ ldfile_possibly_remap_input (const char * filename)
 	  return i->renamed;
 	}
     }
-
+
   return filename;
 }

@@ -686,7 +686,7 @@ ldfile_open_file (lang_input_statement_type *entry)
 	      argv[1] = "missing-lib";
 	      argv[2] = (char *) entry->local_sym_name;
 	      argv[3] = NULL;
-
+
 	      if (verbose)
 		einfo (_("%P: About to run error handling script '%s' with arguments: '%s' '%s'\n"),
 		       argv[0], argv[1], argv[2]);
@@ -891,6 +891,7 @@ ldfile_open_command_file_1 (const char *name, enum script_open_style open_how)
   static struct script_name_list *processed_scripts = NULL;
   struct script_name_list *script;
   size_t len;
+  bool use_text_section_ordering_file = false;

   /* PR 24576: Catch the case where the user has accidentally included
      the same linker script twice.  */
@@ -905,6 +906,23 @@ ldfile_open_command_file_1 (const char *name, enum script_open_style open_how)
 	}
     }

+  if (strcmp (name, "config.text_section_ordering_file") == 0)
+    {
+      /* Support
+
+	 INCLUDE config.text_section_ordering_file;
+
+	 in input text sections in linker script.  */
+      if (config.text_section_ordering_file == NULL)
+	{
+	  lex_push_file (NULL, name, false);
+	  return;
+	}
+
+      name = config.text_section_ordering_file;
+      use_text_section_ordering_file = true;
+    }
+
   /* FIXME: This memory is never freed, but that should not really matter.
      It will be released when the linker exits, and it is unlikely to ever
      be more than a few tens of bytes.  */
@@ -931,7 +949,8 @@ ldfile_open_command_file_1 (const char *name, enum script_open_style open_how)

   lineno = 1;

-  saved_script_handle = ldlex_input_stack;
+  if (!use_text_section_ordering_file)
+    saved_script_handle = ldlex_input_stack;
 }

 /* Open command file NAME in the current directory, -L directories,
diff --git a/ld/ldlang.c b/ld/ldlang.c
index a357f80235f..8a269e29f08 100644
--- a/ld/ldlang.c
+++ b/ld/ldlang.c
@@ -43,6 +43,8 @@
 #include "elf-bfd.h"
 #include "bfdver.h"

+#include "ld-and-gold-sect-alignment-tab.h"
+
 #if BFD_SUPPORTS_PLUGINS
 #include "plugin.h"
 #endif
@@ -2645,8 +2647,9 @@ lang_add_section (lang_statement_list_type *ptr,
   lang_input_section_type *new_section;
   bfd *abfd = link_info.output_bfd;

-  if (wont_add_section_p (section, output))
+  if (wont_add_section_p (section, output)) {
     return;
+  }

   if (sflag_info)
     {
@@ -2710,6 +2713,16 @@ lang_add_section (lang_statement_list_type *ptr,
   if (output->bfd_section == NULL)
     init_os (output, flags);

+  unsigned ldg_alignment_power = ld_and_gold_tab_find (section->name);
+  if (ldg_alignment_power != LD_AND_GOLD_BAD_ALIGN_POW
+      && ldg_alignment_power < 32)
+    {
+      if (section->alignment_power < ldg_alignment_power)
+	{
+	  section->alignment_power = ldg_alignment_power;
+	}
+    }
+
   /* If SEC_READONLY is not set in the input section, then clear
      it from the output section.  */
   output->bfd_section->flags &= flags | ~SEC_READONLY;
@@ -4852,18 +4865,18 @@ ld_is_local_symbol (asymbol * sym)
   /* FIXME: This is intended to skip ARM mapping symbols,
      which for some reason are not excluded by bfd_is_local_label,
      but maybe it is wrong for other architectures.
-     It would be better to fix bfd_is_local_label.  */
+     It would be better to fix bfd_is_local_label.  */
   if (*name == '$')
     return false;

   /* Some local symbols, eg _GLOBAL_OFFSET_TABLE_, are present
      in the hash table, so do not print duplicates here.  */
   struct bfd_link_hash_entry * h;
-  h = bfd_link_hash_lookup (link_info.hash, name, false /* create */,
+  h = bfd_link_hash_lookup (link_info.hash, name, false /* create */,
 			    false /* copy */, true /* follow */);
   if (h == NULL)
     return true;
-
+
   /* Symbols from the plugin owned BFD will not get their own
      iteration of this function, but can be on the link_info
      list.  So include them here.  */
@@ -4953,7 +4966,7 @@ print_input_section (asection *i, bool is_discarded)
 		{
 		  asymbol *     sym = symbol_table[j];
 		  bfd_vma       sym_addr = sym->value + i->output_section->vma;
-
+
 		  if (sym->section == i->output_section
 		      && (sym->flags & BSF_LOCAL) != 0
 		      && sym_addr >= addr
@@ -8601,7 +8614,7 @@ lang_add_string (const char *s)
 	    case 'n': c = '\n'; break;
 	    case 'r': c = '\r'; break;
 	    case 't': c = '\t'; break;
-
+
 	    case '0':
 	    case '1':
 	    case '2':
diff --git a/ld/ldlex.h b/ld/ldlex.h
index 87cac02141d..78009dc1bda 100644
--- a/ld/ldlex.h
+++ b/ld/ldlex.h
@@ -68,6 +68,7 @@ enum option_values
   OPTION_TASK_LINK,
   OPTION_TBSS,
   OPTION_TDATA,
+  OPTION_TEXT_SECTION_ORDERING_FILE,
   OPTION_TTEXT,
   OPTION_TTEXT_SEGMENT,
   OPTION_TRODATA_SEGMENT,
diff --git a/ld/ldmain.c b/ld/ldmain.c
index 06ac2c64fa8..5297d9023f1 100644
--- a/ld/ldmain.c
+++ b/ld/ldmain.c
@@ -44,6 +44,8 @@
 #include "plugin-api.h"
 #endif /* BFD_SUPPORTS_PLUGINS */

+#include "ld-and-gold-sect-alignment-tab.h"
+
 /* Somewhere above, sys/stat.h got included.  */
 #if !defined(S_ISDIR) && defined(S_IFDIR)
 #define	S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
@@ -615,6 +617,8 @@ main (int argc, char **argv)
 	}
     }

+  ld_and_gold_tab_drop ();
+
   if (config.stats)
     {
       long run_time = get_run_time () - start_time;
@@ -1457,7 +1461,7 @@ undefined_symbol (struct bfd_link_info *info,
       argv[1] = "undefined-symbol";
       argv[2] = (char *) name;
       argv[3] = NULL;
-
+
       if (verbose)
 	einfo (_("%P: About to run error handling script '%s' with arguments: '%s' '%s'\n"),
 	       argv[0], argv[1], argv[2]);
@@ -1478,7 +1482,7 @@ undefined_symbol (struct bfd_link_info *info,
 	 carry on to issue the normal error message.  */
     }
 #endif /* SUPPORT_ERROR_HANDLING_SCRIPT */
-
+
   if (section != NULL)
     {
       if (error_count < MAX_ERRORS_IN_A_ROW)
diff --git a/ld/lexsup.c b/ld/lexsup.c
index fe8722313fe..dfb7b7ed225 100644
--- a/ld/lexsup.c
+++ b/ld/lexsup.c
@@ -41,6 +41,7 @@
 #include "ldver.h"
 #include "ldemul.h"
 #include "demangle.h"
+#include "ld-and-gold-env-scripts.h"
 #if BFD_SUPPORTS_PLUGINS
 #include "plugin.h"
 #endif /* BFD_SUPPORTS_PLUGINS */
@@ -58,6 +59,7 @@
 #define	S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
 #endif

+
 static void set_default_dirlist (char *);
 static void set_section_start (char *, char *);
 static void set_segment_start (const char *, char *);
@@ -484,6 +486,9 @@ static const struct ld_option ld_options[] =
   { {"sort-section", required_argument, NULL, OPTION_SORT_SECTION},
     '\0', N_("name|alignment"),
     N_("Sort sections by name or maximum alignment"), TWO_DASHES },
+  { {"text-section-ordering-file", required_argument, NULL, OPTION_TEXT_SECTION_ORDERING_FILE},
+    '\0', N_("FILE"),
+    N_("Sort text sections by FILE"), TWO_DASHES },
   { {"spare-dynamic-tags", required_argument, NULL, OPTION_SPARE_DYNAMIC_TAGS},
     '\0', N_("COUNT"), N_("How many tags to reserve in .dynamic section"),
     TWO_DASHES },
@@ -639,6 +644,7 @@ parse_args (unsigned argc, char **argv)
   unsigned i;
   int is, il, irl;
   int ingroup = 0;
+  char *output_dso = NULL;
   char *default_dirlist = NULL;
   char *shortopts;
   struct option *longopts;
@@ -799,7 +805,33 @@ parse_args (unsigned argc, char **argv)
 	continue;

       if (optc == -1)
-	break;
+	{
+	  char *env_ordering_script = NULL;
+	  if (verbose || config.text_section_ordering_file == NULL)
+	    {
+	      env_ordering_script = ld_and_gold_get_ordering_script (
+		  1, "LD_ORDERING_SCRIPT", "LD_ORDERING_SCRIPT_MAP",
+		  output_dso, ldemul_emulation_name ());
+	    }
+	  if (config.text_section_ordering_file != NULL)
+	    {
+	      if (verbose && env_ordering_script != NULL)
+		{
+		  info_msg (
+		      "Ignoring env ordering script as user provided one\n");
+		}
+	    }
+	  else if (env_ordering_script != NULL)
+	    {
+	      if (verbose)
+		{
+		  info_msg ("Using env ordering script: %s\n",
+			    env_ordering_script);
+		}
+	      config.text_section_ordering_file = env_ordering_script;
+	    }
+	  break;
+	}

       switch (optc)
 	{
@@ -1156,6 +1188,7 @@ parse_args (unsigned argc, char **argv)
 	  link_info.optimize = strtoul (optarg, NULL, 0) != 0;
 	  break;
 	case 'o':
+	  output_dso = optarg;
 	  lang_add_output (optarg, 0);
 	  break;
 	case OPTION_OFORMAT:
@@ -1363,6 +1396,9 @@ parse_args (unsigned argc, char **argv)
 	    einfo (_("%F%P: invalid section sorting option: %s\n"),
 		   optarg);
 	  break;
+	case OPTION_TEXT_SECTION_ORDERING_FILE:
+	  config.text_section_ordering_file = optarg;
+	  break;
 	case OPTION_STATS:
 	  config.stats = true;
 	  break;
diff --git a/ld/scripttempl/arclinux.sc b/ld/scripttempl/arclinux.sc
index 20429df45a8..aa65dcac4b2 100644
--- a/ld/scripttempl/arclinux.sc
+++ b/ld/scripttempl/arclinux.sc
@@ -487,11 +487,12 @@ cat <<EOF
   .text         ${RELOCATING-0} :
   {
     ${RELOCATING+${TEXT_START_SYMBOLS}}
-    ${RELOCATING+*(.text.unlikely .text.*_unlikely .text.unlikely.*)}
-    ${RELOCATING+*(.text.exit .text.exit.*)}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     ${RELOCATING+*(.text.startup .text.startup.*)}
     ${RELOCATING+*(.text.hot .text.hot.*)}
     ${RELOCATING+*(SORT(.text.sorted.*))}
+    ${RELOCATING+*(.text.unlikely .text.*_unlikely .text.unlikely.*)}
+    ${RELOCATING+*(.text.exit .text.exit.*)}
     *(.text .stub${RELOCATING+ .text.* .gnu.linkonce.t.*})
     /* .gnu.warning sections are handled specially by elf.em.  */
     *(.gnu.warning)
diff --git a/ld/scripttempl/avr.sc b/ld/scripttempl/avr.sc
index 61cccfccde8..8f8f629f8a3 100644
--- a/ld/scripttempl/avr.sc
+++ b/ld/scripttempl/avr.sc
@@ -173,6 +173,7 @@ SECTIONS
     KEEP (*(.init8))
     *(.init9)  /* Call main().  */
     KEEP (*(.init9))}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+. = ALIGN(2);
     *(.text.*)
diff --git a/ld/scripttempl/dlx.sc b/ld/scripttempl/dlx.sc
index 8d7a9d53dab..51bfea42a18 100644
--- a/ld/scripttempl/dlx.sc
+++ b/ld/scripttempl/dlx.sc
@@ -22,6 +22,7 @@ SECTIONS
   .text :
   {
     ${RELOCATING+CREATE_OBJECT_SYMBOLS}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+etext = ${DATA_ALIGNMENT};}
   }
diff --git a/ld/scripttempl/elf.sc b/ld/scripttempl/elf.sc
index 1e3c5aa8504..a181a4ed645 100644
--- a/ld/scripttempl/elf.sc
+++ b/ld/scripttempl/elf.sc
@@ -546,6 +546,7 @@ cat <<EOF
     ${RELOCATING+*(.text.unlikely .text.*_unlikely .text.unlikely.*)}
     ${RELOCATING+*(.text.exit .text.exit.*)}
     ${RELOCATING+*(.text.startup .text.startup.*)}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file;}
     ${RELOCATING+*(.text.hot .text.hot.*)}
     ${RELOCATING+*(SORT(.text.sorted.*))}
     *(.text .stub${RELOCATING+ .text.* .gnu.linkonce.t.*})
diff --git a/ld/scripttempl/elf32cr16.sc b/ld/scripttempl/elf32cr16.sc
index cefae424656..88d5774252d 100644
--- a/ld/scripttempl/elf32cr16.sc
+++ b/ld/scripttempl/elf32cr16.sc
@@ -81,6 +81,7 @@ SECTIONS
   .text :
   {
     __TEXT_START = .;
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text) *(.text.*) *(.gnu.linkonce.t.*)
     __TEXT_END = .;
   }${RELOCATING+ > rom}
diff --git a/ld/scripttempl/elf32crx.sc b/ld/scripttempl/elf32crx.sc
index 594eaa1f4fb..5ad69243c39 100644
--- a/ld/scripttempl/elf32crx.sc
+++ b/ld/scripttempl/elf32crx.sc
@@ -77,6 +77,7 @@ SECTIONS
   .text :
   {
     __TEXT_START = .;
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text) *(.text.*) *(.gnu.linkonce.t.*)
     __TEXT_END = .;
   } > rom
diff --git a/ld/scripttempl/elf32msp430.sc b/ld/scripttempl/elf32msp430.sc
index 6edc908a2a0..bf8520ebab3 100644
--- a/ld/scripttempl/elf32msp430.sc
+++ b/ld/scripttempl/elf32msp430.sc
@@ -163,6 +163,7 @@ SECTIONS
     *(.lower.text.* .lower.text)

     . = ALIGN(2);}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+. = ALIGN(2);
     *(.text.*)
diff --git a/ld/scripttempl/elf64bpf.sc b/ld/scripttempl/elf64bpf.sc
index 74154585125..6fc84e25726 100644
--- a/ld/scripttempl/elf64bpf.sc
+++ b/ld/scripttempl/elf64bpf.sc
@@ -508,11 +508,12 @@ cat <<EOF
   .text         ${RELOCATING-0} :
   {
     ${RELOCATING+${TEXT_START_SYMBOLS}}
-    ${RELOCATING+*(.text.unlikely .text.*_unlikely .text.unlikely.*)}
-    ${RELOCATING+*(.text.exit .text.exit.*)}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     ${RELOCATING+*(.text.startup .text.startup.*)}
     ${RELOCATING+*(.text.hot .text.hot.*)}
     ${RELOCATING+*(SORT(.text.sorted.*))}
+    ${RELOCATING+*(.text.unlikely .text.*_unlikely .text.unlikely.*)}
+    ${RELOCATING+*(.text.exit .text.exit.*)}
     *(.text .stub${RELOCATING+ .text.* .gnu.linkonce.t.*})
     /* .gnu.warning sections are handled specially by elf.em.  */
     *(.gnu.warning)
diff --git a/ld/scripttempl/elf64hppa.sc b/ld/scripttempl/elf64hppa.sc
index e85dd397993..4d06ccdb387 100644
--- a/ld/scripttempl/elf64hppa.sc
+++ b/ld/scripttempl/elf64hppa.sc
@@ -412,6 +412,7 @@ cat <<EOF
   .text         ${RELOCATING-0} :
   {
     ${RELOCATING+${TEXT_START_SYMBOLS}}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text .stub${RELOCATING+ .text.* .gnu.linkonce.t.*})
     /* .gnu.warning sections are handled specially by elf.em.  */
     *(.gnu.warning)
diff --git a/ld/scripttempl/elfarc.sc b/ld/scripttempl/elfarc.sc
index 57cd0a561a0..1d9561cfc62 100644
--- a/ld/scripttempl/elfarc.sc
+++ b/ld/scripttempl/elfarc.sc
@@ -288,6 +288,7 @@ cat <<EOF
   .text         ${RELOCATING-0} :
   {
     ${RELOCATING+${TEXT_START_SYMBOLS}}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text .stub${RELOCATING+ .text.* .gnu.linkonce.t.*})
     /* .gnu.warning sections are handled specially by elf.em.  */
     *(.gnu.warning)
diff --git a/ld/scripttempl/elfarcv2.sc b/ld/scripttempl/elfarcv2.sc
index f1b8a69d090..81853dd41ab 100644
--- a/ld/scripttempl/elfarcv2.sc
+++ b/ld/scripttempl/elfarcv2.sc
@@ -188,6 +188,7 @@ SECTIONS

     /* Remaining code.  */
     ${RELOCATING+ . = ALIGN(4);}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text .stub${RELOCATING+ .text.* .gnu.linkonce.t.*})
     /* .gnu.warning sections are handled specially by elf.em.  */
     *(.gnu.warning)
diff --git a/ld/scripttempl/elfd10v.sc b/ld/scripttempl/elfd10v.sc
index e52aaedeac0..4d6e7469f75 100644
--- a/ld/scripttempl/elfd10v.sc
+++ b/ld/scripttempl/elfd10v.sc
@@ -109,6 +109,7 @@ SECTIONS
     KEEP (*(SORT_NONE(.init.*)))
     KEEP (*(SORT_NONE(.fini)))
     KEEP (*(SORT_NONE(.fini.*)))}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+*(.text.*)}
     /* .gnu.warning sections are handled specially by elf.em.  */
diff --git a/ld/scripttempl/elfd30v.sc b/ld/scripttempl/elfd30v.sc
index 97fafb30764..6a8cd0e1197 100644
--- a/ld/scripttempl/elfd30v.sc
+++ b/ld/scripttempl/elfd30v.sc
@@ -125,6 +125,7 @@ SECTIONS
   /* Internal text space or external memory */
   .text :
   {
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+*(.gnu.linkonce.t*)
     KEEP (*(SORT_NONE(.fini)))
diff --git a/ld/scripttempl/elfm68hc11.sc b/ld/scripttempl/elfm68hc11.sc
index ea4321ceeb0..28c1afe19e3 100644
--- a/ld/scripttempl/elfm68hc11.sc
+++ b/ld/scripttempl/elfm68hc11.sc
@@ -318,6 +318,7 @@ SECTIONS
     /* Put startup code at beginning so that _start keeps same address.  */
     ${RELOCATING+${STARTUP_CODE}}

+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+*(.text.*)}
     /* .gnu.warning sections are handled specially by elf.em.  */
diff --git a/ld/scripttempl/elfm68hc12.sc b/ld/scripttempl/elfm68hc12.sc
index a5a623b5f06..6546da5adb8 100644
--- a/ld/scripttempl/elfm68hc12.sc
+++ b/ld/scripttempl/elfm68hc12.sc
@@ -317,6 +317,7 @@ SECTIONS
     /* Put startup code at beginning so that _start keeps same address.  */
     ${RELOCATING+${STARTUP_CODE}}

+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+*(.text.*)}
     /* .gnu.warning sections are handled specially by elf.em.  */
diff --git a/ld/scripttempl/elfm9s12z.sc b/ld/scripttempl/elfm9s12z.sc
index c09b3f7d7a3..5165c15250b 100644
--- a/ld/scripttempl/elfm9s12z.sc
+++ b/ld/scripttempl/elfm9s12z.sc
@@ -303,6 +303,7 @@ SECTIONS
     /* Put startup code at beginning so that _start keeps same address.  */
     ${RELOCATING+${STARTUP_CODE}}

+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+*(.text.*)}
     /* .gnu.warning sections are handled specially by elf.em.  */
diff --git a/ld/scripttempl/elfmicroblaze.sc b/ld/scripttempl/elfmicroblaze.sc
index 5121c5df3a7..93266e8f102 100644
--- a/ld/scripttempl/elfmicroblaze.sc
+++ b/ld/scripttempl/elfmicroblaze.sc
@@ -79,6 +79,7 @@ SECTIONS

   ${RELOCATING+ _ftext  =  .;}
   .text : {
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+*(.text.*)}
     ${RELOCATING+*(.gnu.linkonce.t.*)}
diff --git a/ld/scripttempl/elfxgate.sc b/ld/scripttempl/elfxgate.sc
index 2655e8924f7..3dab6db58c9 100644
--- a/ld/scripttempl/elfxgate.sc
+++ b/ld/scripttempl/elfxgate.sc
@@ -317,6 +317,7 @@ SECTIONS
     /* Put startup code at beginning so that _start keeps same address.  */
     ${RELOCATING+${STARTUP_CODE}}

+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+*(.text.*)}
     /* .gnu.warning sections are handled specially by elf.em.  */
diff --git a/ld/scripttempl/elfxtensa.sc b/ld/scripttempl/elfxtensa.sc
index 7c71525cbeb..038a361c954 100644
--- a/ld/scripttempl/elfxtensa.sc
+++ b/ld/scripttempl/elfxtensa.sc
@@ -418,6 +418,7 @@ cat <<EOF
     ${RELOCATING+${INIT_END}}

     ${RELOCATING+${TEXT_START_SYMBOLS}}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.literal .text .stub${RELOCATING+ .literal.* .text.* .gnu.linkonce.literal.* .gnu.linkonce.t.*.literal .gnu.linkonce.t.*})
     /* .gnu.warning sections are handled specially by elf.em.  */
     *(.gnu.warning)
diff --git a/ld/scripttempl/ft32.sc b/ld/scripttempl/ft32.sc
index e52e75cd924..8c966de3bb1 100644
--- a/ld/scripttempl/ft32.sc
+++ b/ld/scripttempl/ft32.sc
@@ -32,6 +32,7 @@ SECTIONS
 {
   .text :
   {
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text${RELOCATING+*})
     ${RELOCATING+*(.strings)
     *(._pm*)
diff --git a/ld/scripttempl/i386beos.sc b/ld/scripttempl/i386beos.sc
index 1a2422edc04..0b8391fa4d5 100644
--- a/ld/scripttempl/i386beos.sc
+++ b/ld/scripttempl/i386beos.sc
@@ -60,6 +60,7 @@ SECTIONS
   {
     ${RELOCATING+ __text_start__ = . ;}
     ${RELOCATING+ KEEP (*(SORT_NONE(.init)))}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${R_TEXT}
     *(.glue_7t)
diff --git a/ld/scripttempl/i386go32.sc b/ld/scripttempl/i386go32.sc
index 9459f00492c..59d4f917201 100644
--- a/ld/scripttempl/i386go32.sc
+++ b/ld/scripttempl/i386go32.sc
@@ -34,6 +34,7 @@ ${RELOCATING+ENTRY (${ENTRY})}
 SECTIONS
 {
   .text ${RELOCATING+ ${TARGET_PAGE_SIZE}+SIZEOF_HEADERS} : {
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+*(.text.*)}
     ${RELOCATING+*(.gnu.linkonce.t*)}
diff --git a/ld/scripttempl/iq2000.sc b/ld/scripttempl/iq2000.sc
index 47bd777327e..4ccb1634343 100644
--- a/ld/scripttempl/iq2000.sc
+++ b/ld/scripttempl/iq2000.sc
@@ -297,6 +297,7 @@ cat <<EOF
   .text    ${RELOCATING-0} :
   {
     ${RELOCATING+${TEXT_START_SYMBOLS}}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+*(.text.*)}
     *(.stub)
diff --git a/ld/scripttempl/mcorepe.sc b/ld/scripttempl/mcorepe.sc
index 1c5b46e4a6f..37a02a43da3 100644
--- a/ld/scripttempl/mcorepe.sc
+++ b/ld/scripttempl/mcorepe.sc
@@ -66,6 +66,7 @@ SECTIONS
   .text ${RELOCATING+ __image_base__ + __section_alignment__ } :
   {
     ${RELOCATING+ KEEP (*(SORT_NONE(.init)))}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${R_TEXT}
     ${RELOCATING+ *(.text.*)}
diff --git a/ld/scripttempl/mep.sc b/ld/scripttempl/mep.sc
index 6b80c36066b..5eda111c86a 100644
--- a/ld/scripttempl/mep.sc
+++ b/ld/scripttempl/mep.sc
@@ -310,6 +310,7 @@ cat <<EOF
   .text         ${RELOCATING-0} :
   {
     ${RELOCATING+${TEXT_START_SYMBOLS}}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text .stub${RELOCATING+ .text.* .gnu.linkonce.t.*})
     /* .gnu.warning sections are handled specially by elf.em.  */
     *(.gnu.warning)
diff --git a/ld/scripttempl/mmo.sc b/ld/scripttempl/mmo.sc
index 746fb1a062b..305cd816e94 100644
--- a/ld/scripttempl/mmo.sc
+++ b/ld/scripttempl/mmo.sc
@@ -30,6 +30,7 @@ SECTIONS
     ${RELOCATING+ KEEP (*(SORT_NONE(.init)))}
     ${RELOCATING+ PROVIDE (_init_end = .);}

+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+*(.text.*)}
     ${RELOCATING+*(.gnu.linkonce.t*)}
diff --git a/ld/scripttempl/nds32elf.sc b/ld/scripttempl/nds32elf.sc
index 9645e80c567..4d04102d85f 100644
--- a/ld/scripttempl/nds32elf.sc
+++ b/ld/scripttempl/nds32elf.sc
@@ -434,11 +434,12 @@ cat <<EOF
   .text         ${RELOCATING-0} :
   {
     ${RELOCATING+${TEXT_START_SYMBOLS}}
-    ${RELOCATING+*(.text.unlikely .text.*_unlikely .text.unlikely.*)}
-    ${RELOCATING+*(.text.exit .text.exit.*)}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     ${RELOCATING+*(.text.startup .text.startup.*)}
     ${RELOCATING+*(.text.hot .text.hot.*)}
     ${RELOCATING+*(SORT(.text.sorted.*))}
+    ${RELOCATING+*(.text.unlikely .text.*_unlikely .text.unlikely.*)}
+    ${RELOCATING+*(.text.exit .text.exit.*)}
     *(.text .stub${RELOCATING+ .text.* .gnu.linkonce.t.*})
     /* .gnu.warning sections are handled specially by elf.em.  */
     *(.gnu.warning)
diff --git a/ld/scripttempl/pe.sc b/ld/scripttempl/pe.sc
index e9879a9fee4..e3169d34656 100644
--- a/ld/scripttempl/pe.sc
+++ b/ld/scripttempl/pe.sc
@@ -91,6 +91,7 @@ SECTIONS
   .text ${RELOCATING+ __image_base__ + ( __section_alignment__ < ${TARGET_PAGE_SIZE} ? . : __section_alignment__ )} :
   {
     ${RELOCATING+KEEP (*(SORT_NONE(.init)))}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${R_TEXT}
     ${RELOCATING+ *(.text.*)}
diff --git a/ld/scripttempl/pep.sc b/ld/scripttempl/pep.sc
index df1f4116ca4..8f036af6db5 100644
--- a/ld/scripttempl/pep.sc
+++ b/ld/scripttempl/pep.sc
@@ -92,6 +92,7 @@ SECTIONS
   .text ${RELOCATING+ __image_base__ + ( __section_alignment__ < ${TARGET_PAGE_SIZE} ? . : __section_alignment__ )} :
   {
     ${RELOCATING+KEEP (*(SORT_NONE(.init)))}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${R_TEXT}
     ${RELOCATING+ *(.text.*)}
diff --git a/ld/scripttempl/pru.sc b/ld/scripttempl/pru.sc
index 3ff86bc61c7..d4d79cbcf82 100644
--- a/ld/scripttempl/pru.sc
+++ b/ld/scripttempl/pru.sc
@@ -110,6 +110,7 @@ SECTIONS
     ${RELOCATING+KEEP (*(.init0))}

     ${RELOCATING+. = ALIGN(4);}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+. = ALIGN(4);}
     ${RELOCATING+*(.text.*)}
diff --git a/ld/scripttempl/v850.sc b/ld/scripttempl/v850.sc
index 3de6bdd2ef5..c5a02da86f4 100644
--- a/ld/scripttempl/v850.sc
+++ b/ld/scripttempl/v850.sc
@@ -76,6 +76,7 @@ SECTIONS

   .text		:
   {
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+*(.text.*)}

diff --git a/ld/scripttempl/v850_rh850.sc b/ld/scripttempl/v850_rh850.sc
index 2c70914c119..682868b1252 100644
--- a/ld/scripttempl/v850_rh850.sc
+++ b/ld/scripttempl/v850_rh850.sc
@@ -80,6 +80,7 @@ SECTIONS

   .text		:
   {
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+*(.text.*)}

diff --git a/ld/scripttempl/visium.sc b/ld/scripttempl/visium.sc
index d11dafd7157..69a39a4e795 100644
--- a/ld/scripttempl/visium.sc
+++ b/ld/scripttempl/visium.sc
@@ -67,6 +67,7 @@ SECTIONS

   .text ${RELOCATING-0} : {
     ${RELOCATING+ _ftext  =  .;}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+*(.text.*)}
     ${RELOCATING+*(.gnu.linkonce.t.*)}
diff --git a/ld/scripttempl/xstormy16.sc b/ld/scripttempl/xstormy16.sc
index ccae0a2e04f..e2f26c6dda4 100644
--- a/ld/scripttempl/xstormy16.sc
+++ b/ld/scripttempl/xstormy16.sc
@@ -178,6 +178,7 @@ SECTIONS
   .text    ${RELOCATING-0} :
   {
     ${RELOCATING+${TEXT_START_SYMBOLS}}
+    ${RELOCATING+INCLUDE config.text_section_ordering_file}
     *(.text)
     ${RELOCATING+*(.text.*)}
     *(.stub)
diff --git a/ld/testsuite/ld-elf/text-order-1.d b/ld/testsuite/ld-elf/text-order-1.d
new file mode 100644
index 00000000000..a0c3e9692ab
--- /dev/null
+++ b/ld/testsuite/ld-elf/text-order-1.d
@@ -0,0 +1,13 @@
+#source: text-order-1a.s
+#source: text-order-1b.s
+#ld: -shared --text-section-ordering-file text-order-1.t
+#nm: -n
+#target: *-*-linux* *-*-gnu* arm*-*-uclinuxfdpiceabi
+# generic linker targets don't support --text-section-ordering-file
+
+#...
+[0-9a-f]+ T yyy
+[0-9a-f]+ T bar
+[0-9a-f]+ T xxx
+[0-9a-f]+ T foo
+#pass
diff --git a/ld/testsuite/ld-elf/text-order-1.t b/ld/testsuite/ld-elf/text-order-1.t
new file mode 100644
index 00000000000..44334926833
--- /dev/null
+++ b/ld/testsuite/ld-elf/text-order-1.t
@@ -0,0 +1,4 @@
+*(.text.yyy)
+*(.text.bar)
+*(.text.xxx)
+*(.text.foo)
diff --git a/ld/testsuite/ld-elf/text-order-1a.s b/ld/testsuite/ld-elf/text-order-1a.s
new file mode 100644
index 00000000000..74291212ff5
--- /dev/null
+++ b/ld/testsuite/ld-elf/text-order-1a.s
@@ -0,0 +1,10 @@
+	.section .text.foo,"ax",%progbits
+	.globl	foo
+	.type	foo, %function
+foo:
+	.byte 0
+	.section .text.bar,"ax",%progbits
+	.type	bar, %function
+	.globl	bar
+bar:
+	.byte 0
diff --git a/ld/testsuite/ld-elf/text-order-1b.s b/ld/testsuite/ld-elf/text-order-1b.s
new file mode 100644
index 00000000000..c106034cf33
--- /dev/null
+++ b/ld/testsuite/ld-elf/text-order-1b.s
@@ -0,0 +1,10 @@
+	.section .text.xxx,"ax",%progbits
+	.globl	xxx
+	.type	xxx, %function
+xxx:
+	.byte 0
+	.section .text.yyy,"ax",%progbits
+	.type	yyy, %function
+	.globl	yyy
+yyy:
+	.byte 0
--
2.34.1

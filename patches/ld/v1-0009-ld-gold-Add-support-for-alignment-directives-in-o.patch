From 88f5831cb32082c1fb28f16a5a0d3abea3693086 Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Mon, 22 Apr 2024 18:14:21 -0500
Subject: ld/gold: Add support for alignment directives in order files

---
 gold/main.cc                             |   5 +
 gold/output.cc                           |  12 ++
 include/ld-and-gold-env-scripts.h        | 155 ++++++++++++++++++++++-
 include/ld-and-gold-sect-alignment-tab.h | 143 +++++++++++++++++++++
 ld/ldlang.c                              |  12 ++
 ld/ldmain.c                              |   4 +
 6 files changed, 330 insertions(+), 1 deletion(-)
 create mode 100644 include/ld-and-gold-sect-alignment-tab.h

diff --git a/gold/main.cc b/gold/main.cc
index edc2001f611..bd5b8a99011 100644
--- a/gold/main.cc
+++ b/gold/main.cc
@@ -50,6 +50,8 @@
 #include "gdb-index.h"
 #include "timer.h"
 
+#include "ld-and-gold-sect-alignment-tab.h"
+
 using namespace gold;
 
 // This function emits the commandline to a hard-coded file in temp.
@@ -326,6 +328,9 @@ main(int argc, char** argv)
   if (mapfile != NULL)
     mapfile->close();
 
+  ld_and_gold_tab_drop ();
+
+
   if (parameters->options().fatal_warnings()
       && errors.warning_count() > 0
       && errors.error_count() == 0)
diff --git a/gold/output.cc b/gold/output.cc
index 31be6270680..0eb892a27df 100644
--- a/gold/output.cc
+++ b/gold/output.cc
@@ -46,6 +46,8 @@
 #include "layout.h"
 #include "output.h"
 
+#include "ld-and-gold-sect-alignment-tab.h"
+
 // For systems without mmap support.
 #ifndef HAVE_MMAP
 # define mmap gold_mmap
@@ -2409,6 +2411,16 @@ Output_section::add_input_section(Layout* layout,
 				    &addralign))
     input_section_size = uncompressed_size;
 
+  uint64_t alignment = ld_and_gold_tab_find (secname);
+  if (alignment != LD_AND_GOLD_BAD_ALIGN_POW && alignment < 32)
+    {
+      alignment = uint64_t (1) << alignment;
+      if (alignment > addralign)
+	{
+	  addralign = alignment;
+	}
+    }
+
   if ((addralign & (addralign - 1)) != 0)
     {
       object->error(_("invalid alignment %lu for section \"%s\""),
diff --git a/include/ld-and-gold-env-scripts.h b/include/ld-and-gold-env-scripts.h
index 72ca5689e40..5018e98437f 100644
--- a/include/ld-and-gold-env-scripts.h
+++ b/include/ld-and-gold-env-scripts.h
@@ -8,6 +8,155 @@
 #include <unistd.h>
 #include <ctype.h>
 
+#include "ld-and-gold-sect-alignment-tab.h"
+
+htab_t G_ld_and_gold_alignment_tab = NULL;
+
+static int
+ld_and_gold_is_whitespace (char c)
+{
+  return c == ' ' || c == '\t';
+}
+
+static int
+ld_and_gold_is_digit (char c)
+{
+  return c >= '0' && c <= '9';
+}
+
+static struct ldg_func_sect_alignment_t *
+ld_and_gold_find_alignment (const char *line, size_t line_sz, int is_ld)
+{
+  const char *sect_begin;
+  const char *sect_end;
+  const char *begin_align_info;
+  char *sect_name_dup;
+  size_t sect_name_len, alloc_size;
+  void *mem;
+  const char to_match[] = { 'a', '=' };
+  unsigned to_match_idx = 0;
+  const char *line_end = line + line_sz;
+  if (line_sz == 0)
+    {
+      return NULL;
+    }
+
+  sect_begin = (const char *) memchr (line, '.', line_sz);
+  if (sect_begin == NULL)
+    {
+      return NULL;
+    }
+  line_sz = line_end - sect_begin;
+
+  sect_end = (const char *) memchr (sect_begin, is_ld ? ')' : ' ', line_sz);
+  if (sect_end == NULL)
+    {
+      return NULL;
+    }
+  line_sz = line_end - sect_end;
+  begin_align_info = (const char *) memchr (sect_end, '#', line_sz);
+  if (begin_align_info == NULL)
+    {
+      return NULL;
+    }
+  ++begin_align_info;
+
+  for (;;)
+    {
+      if (begin_align_info >= line_end)
+	{
+	  return NULL;
+	}
+      if (to_match_idx < sizeof (to_match)
+	  && begin_align_info[0] == to_match[to_match_idx])
+	{
+	  ++to_match_idx;
+	}
+      else if (!ld_and_gold_is_whitespace (begin_align_info[0]))
+	{
+	  break;
+	}
+      ++begin_align_info;
+    }
+
+  if (!ld_and_gold_is_digit (begin_align_info[0]))
+    {
+      return NULL;
+    }
+
+  unsigned alignment_power = begin_align_info[0] - '0';
+  ++begin_align_info;
+  if (begin_align_info < line_end
+      && ld_and_gold_is_digit (begin_align_info[0]))
+    {
+      alignment_power = alignment_power * 10 + begin_align_info[0] - '0';
+      ++begin_align_info;
+    }
+  if (begin_align_info < line_end
+      && !(ld_and_gold_is_whitespace (begin_align_info[0])
+	   || begin_align_info[0] == '\n' || begin_align_info[0] == '\0'))
+    {
+      return NULL;
+    }
+  sect_name_len = sect_end - sect_begin;
+  alloc_size = sizeof (struct ldg_func_sect_alignment_t) + sect_name_len + 1;
+  mem = malloc (alloc_size);
+  if (mem == NULL)
+    {
+      return NULL;
+    }
+
+  sect_name_dup = ((char *) mem) + sizeof (struct ldg_func_sect_alignment_t);
+  struct ldg_func_sect_alignment_t *func_sect_alignment
+      = (struct ldg_func_sect_alignment_t *) mem;
+
+  memcpy (sect_name_dup, sect_begin, sect_name_len);
+  sect_name_dup[sect_name_len] = '\0';
+  func_sect_alignment->func_sect_name_ = sect_name_dup;
+  func_sect_alignment->alignment_power_ = alignment_power;
+  func_sect_alignment->found_ = 0;
+  return func_sect_alignment;
+}
+
+static void
+ld_and_gold_add_alignments (const char *path, int is_ld)
+{
+  FILE *fp = NULL;
+  char *line = NULL;
+  size_t line_sz = 0;
+
+  fp = fopen (path, "r");
+  if (fp == NULL)
+    {
+      return;
+    }
+  for (;;)
+    {
+      ssize_t nread_s = getline (&line, &line_sz, fp);
+      size_t nread;
+      struct ldg_func_sect_alignment_t *alignment_info;
+      if (nread_s < 0)
+	{
+	  if (line != NULL)
+	    {
+	      free (line);
+	    }
+	  break;
+	}
+
+      nread = nread_s;
+      alignment_info = ld_and_gold_find_alignment (line, nread, is_ld);
+      if (alignment_info != NULL)
+	{
+	  if (ld_and_gold_tab_insert (alignment_info))
+	    {
+	      free (alignment_info);
+	    }
+	}
+    }
+  fclose (fp);
+}
+
 /* Find where the ".so" starts in a dso. If ".so" exists return offset to the
  * 'o'. Otherwise return 0.  */
 static size_t
@@ -64,7 +213,11 @@ ld_and_gold_process_ordering_script_from_map (char *linker_script, int is_ld)
       return -1;
     }
 
-  (void) is_ld;
+  if (linker_script != NULL)
+    {
+      ld_and_gold_add_alignments (linker_script, is_ld);
+    }
+
   return 0;
 }
 
diff --git a/include/ld-and-gold-sect-alignment-tab.h b/include/ld-and-gold-sect-alignment-tab.h
new file mode 100644
index 00000000000..b026777282f
--- /dev/null
+++ b/include/ld-and-gold-sect-alignment-tab.h
@@ -0,0 +1,143 @@
+#ifndef BINUTILS_D_INCLUDE_D_LD_AND_GOLD_SECT_ALIGNMENT_TAB_H_
+#define BINUTILS_D_INCLUDE_D_LD_AND_GOLD_SECT_ALIGNMENT_TAB_H_ 1
+
+#include "hashtab.h"
+
+#define LD_AND_GOLD_BAD_ALIGN_POW 0
+
+extern htab_t G_ld_and_gold_alignment_tab;
+struct ldg_func_sect_alignment_t
+{
+  const char *func_sect_name_;
+  unsigned alignment_power_;
+  int found_;
+};
+
+static int
+ld_and_gold_fsa_eq (const void *lhs, const void *rhs)
+{
+  const struct ldg_func_sect_alignment_t *lhs_fda
+      = (const struct ldg_func_sect_alignment_t *) lhs;
+  const struct ldg_func_sect_alignment_t *rhs_fda
+      = (const struct ldg_func_sect_alignment_t *) rhs;
+
+  return strcmp (lhs_fda->func_sect_name_, rhs_fda->func_sect_name_) == 0;
+}
+
+static hashval_t
+ld_and_gold_fsa_hash (const void *n)
+{
+  const struct ldg_func_sect_alignment_t *n_fda
+      = (const struct ldg_func_sect_alignment_t *) n;
+  const char *str = n_fda->func_sect_name_;
+  hashval_t hv = 0;
+  for (;;)
+    {
+      char c = str[0];
+      if (c == '\0')
+	{
+	  break;
+	}
+      hv += (hv * 65599) + c;
+      ++str;
+    }
+  return hv ^ (hv >> 16);
+}
+static int
+ld_and_gold_fda_startswith (const struct ldg_func_sect_alignment_t *fda,
+			    const char *prefix)
+{
+  return strncmp (fda->func_sect_name_, prefix, strlen (prefix)) == 0;
+}
+static void
+ld_and_gold_fsa_del (void *p)
+{
+  struct ldg_func_sect_alignment_t *fda
+      = (struct ldg_func_sect_alignment_t *) p;
+  if (!fda->found_)
+    {
+      /* If found in one of these sections its likely just due to duplicate. */
+      if (!ld_and_gold_fda_startswith (fda, ".text.cold.")
+	  && !ld_and_gold_fda_startswith (fda, ".text.hot.")
+	  && !ld_and_gold_fda_startswith (fda, ".text.unlikely.")
+	  && !ld_and_gold_fda_startswith (fda, ".text.likely."))
+	{
+	  printf ("Warning: %s was never aligned to %u\n",
+		  fda->func_sect_name_, fda->alignment_power_);
+	}
+    }
+  free (p);
+}
+
+static htab_t
+ld_and_gold_tab_get (void)
+{
+  if (G_ld_and_gold_alignment_tab == NULL)
+    {
+      G_ld_and_gold_alignment_tab = htab_create (
+	  32, ld_and_gold_fsa_hash, ld_and_gold_fsa_eq, ld_and_gold_fsa_del);
+    }
+  return G_ld_and_gold_alignment_tab;
+}
+static int
+ld_and_gold_tab_drop (void)
+{
+  int ret = 0;
+  if (G_ld_and_gold_alignment_tab == NULL)
+    {
+      return ret;
+    }
+  ret = htab_elements (G_ld_and_gold_alignment_tab) != 0;
+  htab_delete (G_ld_and_gold_alignment_tab);
+  return ret;
+}
+
+#if !(defined LD_AND_GOLD_NWG_TESTING)
+static int
+ld_and_gold_tab_insert (struct ldg_func_sect_alignment_t *fda)
+{
+  htab_t tab = ld_and_gold_tab_get ();
+  void **slot;
+  if (tab == NULL)
+    {
+      return 1;
+    }
+  slot = htab_find_slot (tab, (void *) fda, INSERT);
+  if (slot == NULL)
+    {
+      return 1;
+    }
+  *slot = (void *) fda;
+  return 0;
+}
+#endif
+
+static unsigned
+ld_and_gold_tab_find (const char *s)
+{
+  struct ldg_func_sect_alignment_t fda = { s, 0, 0 };
+  htab_t tab = ld_and_gold_tab_get ();
+  unsigned alignment_power = LD_AND_GOLD_BAD_ALIGN_POW;
+  struct ldg_func_sect_alignment_t *found_fda;
+  void **slot;
+  if (tab == NULL)
+    {
+      return alignment_power;
+    }
+  slot = htab_find_slot (tab, (void *) &fda, NO_INSERT);
+  if (slot == NULL)
+    {
+      return alignment_power;
+    }
+  found_fda = ((struct ldg_func_sect_alignment_t *) (*slot));
+  alignment_power = found_fda->alignment_power_;
+  found_fda->found_ = 1;
+  if (alignment_power == LD_AND_GOLD_BAD_ALIGN_POW)
+    {
+      printf ("Warning: %s has bad alignment power\n",
+	      found_fda->func_sect_name_);
+    }
+  return alignment_power;
+}
+
+#endif
diff --git a/ld/ldlang.c b/ld/ldlang.c
index a357f80235f..ba3c17ad9f2 100644
--- a/ld/ldlang.c
+++ b/ld/ldlang.c
@@ -43,6 +43,8 @@
 #include "elf-bfd.h"
 #include "bfdver.h"
 
+#include "ld-and-gold-sect-alignment-tab.h"
+
 #if BFD_SUPPORTS_PLUGINS
 #include "plugin.h"
 #endif
@@ -2710,6 +2712,16 @@ lang_add_section (lang_statement_list_type *ptr,
   if (output->bfd_section == NULL)
     init_os (output, flags);
 
+  unsigned ldg_alignment_power = ld_and_gold_tab_find (section->name);
+  if (ldg_alignment_power != LD_AND_GOLD_BAD_ALIGN_POW
+      && ldg_alignment_power < 32)
+    {
+      if (section->alignment_power < ldg_alignment_power)
+	{
+	  section->alignment_power = ldg_alignment_power;
+	}
+    }
+
   /* If SEC_READONLY is not set in the input section, then clear
      it from the output section.  */
   output->bfd_section->flags &= flags | ~SEC_READONLY;
diff --git a/ld/ldmain.c b/ld/ldmain.c
index 06ac2c64fa8..86e1b05acc5 100644
--- a/ld/ldmain.c
+++ b/ld/ldmain.c
@@ -44,6 +44,8 @@
 #include "plugin-api.h"
 #endif /* BFD_SUPPORTS_PLUGINS */
 
+#include "ld-and-gold-sect-alignment-tab.h"
+
 /* Somewhere above, sys/stat.h got included.  */
 #if !defined(S_ISDIR) && defined(S_IFDIR)
 #define	S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
@@ -615,6 +617,8 @@ main (int argc, char **argv)
 	}
     }
 
+  ld_and_gold_tab_drop ();
+
   if (config.stats)
     {
       long run_time = get_run_time () - start_time;
-- 
2.34.1

